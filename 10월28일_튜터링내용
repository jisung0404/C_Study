- 포인터
	- 다른 변수의 메모리 주소를 값으로 저장하는 변수.
		- 포인터는 데이터를 저장하는 대신. 데이터가 어디에 저장되어 있는지 그 위치를 지정.
		- C언어에서 메모리에 직접 접근하고 동적 메모리를 관리하는 핵심요소.
- 포인터 주소 연산자 : &
	- 일반 변수 앞에 붙여 해당 변수의 메모리 주소를 얻어내는 연산자
		- 해당 변수가 위치하는 메모리 주소를 가져옴.
		ex: 
			int num = 100;
			printf("num의 값 : %d\n", num); 
			printf("num의 주소 : %p\n", &num)       // %p는 주소 출력을 위한 서식 지정자
- 포인터 변수 선언 : *
	- 주소 연산자 &로 얻은 주소 값을 저장할 변수
		- 포인터 변수가 가리키는 곳에 해당 자료형의 데이터가 있다는 의미
		ex:
			int *ptr;      // 정수 (int)를 가리키는 포인터 변수 선언
			char *ptr_c;    // char 가리키는 포인터 변수 선언
- 역참조 연산자
	- * : 포인터 변수 앞에 붙어 포인터가 가리키는 주소의 값을 가져옴.
	ex:
		int num = 10;
		int *ptr = &num;    // ptr은 num의 주소를 저장
		printf("ptr의 값: &d\n", *ptr);    // 출력 : 10 (ptr이 가리키는 곳의 값)
		*ptr = 20;                 // p가 가리키는 곳 (즉, num)의 값을 20으로 변경
		printf("num의 값 : %d\n", num);    // 출력 : 20
			
			- ptr은 변수 num 내용 수정 가능
- 포인터 사용
	- 선언 시 : 포인터 변수임을 의미.
		- int *p;   -> "p는 int형 데이터를 가리키는 포인터 변수입니다."
	- 사용 시 : 역참조(주소에 접근)를 표현.
		- *p=10;   -> "p가 가리키는 곳에 10을 저장하세요."
- void 포인터
	- 가리키는 자료형이 정해지지 않은 포인터
		ex: void *ptr;
	- 모든 자료형의 주소 저장 가능.
		- 하지만 역참조(*ptr) 및 포인터 연산 (ptr++) 불가능 (크기를 모르기 때문.)
		- 역참조를 위해서는 반드시 사용 전에 원하는 자료형으로 형 변환 필요
- 포인터 연산
	- 포인터에 덧셈/뺄셈을 하면 실제로 포인터가 가리키는 자료형의 크기만큼 메모리 주소 이동
		ex:
			int *ptr_i;
			char *ptr_c;
			ptr_i = (int *) 0x1004    // *ptr_i : 21
			ptr_i = ptr_i + 1           // 0x1008 : int 크기(4B) 만큼 증가
			                   // *ptr_i : 45
			ptr__c = (char * ) 0x1010   // *ptr_c : 'a'
			ptr_c = ptr_c+1               // 0x1011 : char 크기(1B)만큼 증가
							  // *ptr_c : 'b'
